<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven跳过单元测试]]></title>
    <url>%2F2019%2F01%2F09%2FMaven%E8%B7%B3%E8%BF%87%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[项目构建打包的时候，想要跳过一系列的单元测试，可以设置 skipTests 属性为 true。 12345678910111213141516&lt;project&gt; [...] &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.12.4&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; [...]&lt;/project&gt; 也可以通过命令行执行命令来跳过测试： 1mvn install -DskipTests 还有另一个跳过测试的参数： maven.test.skip ，这个参数还会跳过编译测试部分。 maven.test.skip 实际上是控制 Surefire, Failsafe 和 Compiler Plugin这三个插件的执行。 1mvn install -Dmaven.test.skip=true 默认跳过如果想要默认跳过测试，但是又想可以通过命令行来控制执行测试，就可以在pom.xml中添加以下配置： 1234567891011121314151617181920&lt;project&gt; [...] &lt;properties&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/properties&gt; [...] &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.12.4&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;$&#123;skipTests&#125;&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; [...]&lt;/project&gt; 这样就可以默认运行测试，也可以通过命令控制执行测试。 1mvn install -DskipTests=false 同样，其他Maven插件使用boolean类型的参数也可以这样使用。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发（1）——代码的组成]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[小程序由配置代码JSON文件、模板代码 WXML 文件、样式代码 WXSS文件以及逻辑代码 JavaScript文件组成。通过创建一个快速模板，来了解这几种文件的作用。 创建项目选择&quot;建立普通快速启动模板&quot;，进入项目后，可以看到以下的项目目录结构： Json配置文件在根目录下可以找到 app.json 文件，代码如下： 123456789101112&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;&#125; JSON文件是静态配置，小程序是无法在运行过程中去动态更新JSON 配置文件从而发生对应的变化的。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发（1）——hello world]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94hello%20world%2F</url>
    <content type="text"><![CDATA[每次学习新的一门语言和技术，都以写hello world开始。现在学习开发小程序，也以hello world开始。 首先要下载微信开发者工具： https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html 1、创建项目 首先选择项目目录，若还没有注册AppID，可以选择使用测试号的ID，然后填写项目名称，最后取消勾选“建立普通快速启动模板”的选项，不使用模板，自己来添加代码。 2、添加Hello world代码在根目录下创建app.json，其内容如下。 123&#123; "pages": ["pages/index/index"]&#125; 在根目录下新建pages目录，然后在pages目录下新建index目录，接着在index目录下创建两个文件index.wxml和index.js。 index.wxml的内容：&lt;text&gt;Hello World&lt;/text&gt; index.js的内容：Page({}) 3、编译项目点击编译，默认使用普通编译。 编译后会生成多两个文件，index.json 和 index.wxss. index.json的内容： 123&#123; "usingComponents": &#123;&#125;&#125; index.wxss的内容(只有一行注释)：/* pages/index/index.wxss */ 最后内容显示了hello world 总结小程序的主要开发语言是 JavaScript 。小程序的开发渲染线程和脚本线程是分别运行在不同的线程中，逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，所以前端的一些库，比如JQuery在小程序中是无法运行的。 小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具。 小程序的运行环境： 运行环境 逻辑层 渲染层 iOS JavaScriptCore WKWebView 安卓 X5 JSCore X5浏览器 小程序开发者工具 NWJS Chrome WebView]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript函数闭包]]></title>
    <url>%2F2018%2F10%2F17%2FJavaScript%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包要解决的问题是：一个函数可以拥有私有变量，并且外部可以通过闭包访问该私有变量，如特权方法（类似JavaBean 的写法）： 123456789function Student(value) &#123; var name =value; this.getName= function() &#123; return name; &#125;; this.setName= function(value) &#123;name = value; &#125;;&#125; 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。 闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。 当在一个函数内定义另外一个函数就会产生闭包。 为了便于理解，我们可以简单的将闭包理解为： 闭包：是指有权访问另外一个函数作用域中的变量的函数 闭包的注意点： 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（PublicMethod），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 闭包的用途： 闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 1234567891011121314151617181920212223function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google机器学习笔记]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[###框架处理 监督式机器学习 ​ 机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测 标签 y ​ 预测的目标，y变量 特征 xi ​ 输入变量，x变量 。指可以量化的指标！ ​ （简单机器学习可能会使用单个特征，复杂的机器学习可能会使用百万个特征） 样本 特定实例x ​ 有标签样本 {特征，标签} ​ 无标签样本 {特征，？} 模型 映射模型 ​ 使用有标签样本来（训练）——&gt;模型(预测)——&gt;无标签样本的标签 ​ 模型生命周期两个阶段： ​ 1. 训练。有标签样本（展示）——&gt;模型，模型（学习）——&gt; 关系：特征&amp;标签 ​ 2. 推断。模型 [ y ‘ / f（x）]（预测）——&gt;无标签样本 回归和分类 ​ 回归模型可以预测连续值（eg: 房价趋势，股本趋势） ​ 分类模型可以预测离散值（eg: 垃圾邮件还是非垃圾邮件？ 图片是猫还是狗？） 深入了解机器学习线性回归 ​$$线性函数：y = w x + b$$ $$模型方程式 ：y’ = b + w1* x1$$ ​ y’ : 预测的标签 ​ b：偏差， 称为w0 ​ w1：特征1的权重 ​ x1：特征值 ​ 可以用多个特征值来表示更复杂的模型。例如，具有三个特征值 模型: ​$$y’ = b + w1x1+w2x2+w3x3$$误差 回归损失函数 ​$$给定样本的L损失，即平方差 =（观察值 - 预测值）^2 = ( y - y &apos;)^2 $$​ 数据集上的L损失 ，求和所以样本的损失 均方误差（MSE） ​ 每个样本的平均平方损失。 ​ 数据集上的L损失 / N样本数 训练与损失 ​ 训练模型表示通过有标签样本来学习（确定）所以权重和偏差的理性值。 ​ 经验风险最小化：检查多个样本并尝试找出可最大限度地减少算是的模型 ###降低损失 ​ 平方差 （了解指定样本的损失变化情况） 梯度步长 梯度下降法 ​ 梯度是一个矢量，特征（方向，大小） ​ 凸型，只有一个最低点，即只存在一个斜率正好为0 的值 ​ 非凸型，有多个最低点。很大程度上取决于初始值（神经网络） 随机梯度下降法（SGD） ​ 在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。 ​ 实际上，批量大小越大，出现冗余的可能性就越高 小批量梯度下降法（小批量SGD） 迭代策略 ​ 可以很好地扩展到大型数据集 线性回归——损失函数 偏导数 学习速率 ​ 也称为步长 ​ 如果梯度大小为2.5，学习速率是0.01，则梯度下降算法会选择距离前一个0.025的位置作为下一个点 ​ 如果学习效率过小，会发费很长的时间。如果过大，就好在U型底部随意弹跳 Golddilocks principle playground.tensorflow.org 学习速率和收敛 ​]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试整理]]></title>
    <url>%2F2017%2F10%2F28%2FJava%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、java基础1、线程池的种类，区别和使用场景newCachedThreadPool： 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列) 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。 适用：执行很多短期异步的小程序或者负载较轻的服务器 newFixedThreadPool： 底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue() 无解阻塞队列 通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列) 适用：执行长期的任务，性能好很多 newSingleThreadExecutor: 底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无解阻塞队列 通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列) 适用：一个任务一个任务执行的场景 NewScheduledThreadPool: 底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列 通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构 适用：周期性执行任务的场景 线程池任务执行流程： 当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务 当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。 2、分析线程池的实现原理和线程的调度过程 一个线程池包括以下四个基本组成部分： 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务； 工作线程（WorkThread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。 3、线程池如何调优在使用线程池时，有一个因素非常关键：调节线程池的大小对获得最好的性能至关重要。所有线程池的工作方式本质是一样的：有一个任务队列，一定数量的线程会从该任务队列获取任务然后执行。任务的结果可以发回客户端，或保存到数据库，或保存到某个内部数据结构中，等等。但是在执行完任务后，这个线程会返回任务队列，检索另一个任务并执行。 线程池有最小线程数和最大线程数。池中会有最小数目的线程随时待命，等待任务指派给它们。因为创建线程的成本非常高昂，这样可以提高任务提交时的整体性能。线程池的最小线程数称作核心池大小，考虑ThreadPoolExecutor最简单的情况，如果有个任务要执行，而所有的并发线程都在忙于执行另一个任务，就会启动一个新线程，直到创建的线程达到最大线程数。 一般我们会从以下几个方面对线程池进行设置： 1、设置最大线程数 对于给定硬件上的给定负载，最大线程数设置为多少最好呢？它取决于负载特性以及底层硬件。特别是，最优线程数还与每个任务阻塞的频率有关。假设JVM有4个CPU可用，很明显最大线程数至少要设置为4。的确，除了处理这些任务，JVM还有些线程要做其他的事，但是它们几乎从来不会占用一个完整的CPU，至于这个数值是否要大于4，则需要进行大量充分的测试。 有以下两点需要注意： 一旦服务器成为瓶颈，向服务器增加负载时非常有害的； 对于CPU密集型或IO密集型的机器增加线程数实际会降低整体的吞吐量； 2、设置最小线程数 大部分情况下，开发者会直截了当的将他们设置成同一个值。将最小线程数设置为其他某个值（比如1），出发点是为了防止系统创建太多线程，以节省系统资源。指定一个最小线程数的负面影响相当小。如果第一次就有很多任务要执行，会有负面影响：这是线程池需要创建一个新线程。 3、线程池任务大小 等待线程池来执行的任务会被保存到某个队列或列表中；当池中有线程可以执行任务时，就从队列中拉出一个。这会导致不均衡：队列中任务的数量可能变得非常大。如果队列太大，其中的任务就必须等待很长时间，直到前面的任务执行完毕。 4、设置ThreadPoolExecutor的大小 线程池的一般行为是这样的：创建时准备最小数目的线程，如果来了一个任务，而此时所有的线程都在忙碌，则启动一个新线程（一直到达到最大线程数），任务就会立即执行。否则，任务被加入到等待队列，如果队列中已经无法加入新任务，则拒接之。根据所选任务队列的类型，ThreadPoolExecutor会决定何时会启动一个新线程。有以下三种可能： SynchronousQueue 如果ThreadPoolExecutor搭配的是SynchronousQueue，则线程池的行为和我们预期的一样，它会考虑线程数：如果所有的线程都在忙碌，而且池中的线程数尚未达到最大，则会为新任务启动一个新线程。然而这个队列没办法保存等待的任务：如果来了一个任务，创建的线程数已经达到最大值，而且所有的线程都在忙碌，则新的任务都会被拒绝，所以如果是管理少量的任务，这是个不错的选择，对于其他的情况就不适合了。 无界队列 如果ThreadPoolExecutor搭配的是无界队列，如LinkedBlockingQueue，则不会拒绝任何任务（因为队列大小没有限制）。这种情况下，ThreadPoolExecutor最多仅会按照最小线程数创建线程，也就是说最大线程池大小被忽略了。如果最大线程数和最小线程数相同，则这种选择和配置了固定线程数的传统线程池运行机制最为接近。 有界队列 搭配了有界队列，如ArrayBlockingQueue的ThreadPoolExecutor会采用一个非常负责的算法。比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。 如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。 4、动态代理的几种方式 Proxy代理 关于动态代理设计模式很可能题主就在不知不觉中使用了，例如Spring中的AOP，Struts2中的拦截器等。 123456package test;public interface Subject &#123; public void doSomething(); &#125; 123456789package test;public class RealSubject implements Subject &#123; public void doSomething() &#123; System.out.println( "call doSomething()" ); &#125; &#125; 12345678910package test;public class SubjectProxy implements Subject&#123; Subject subimpl = new RealSubject(); public void doSomething() &#123; subimpl.doSomething(); &#125;&#125; 12345678910package test;public class TestProxy &#123; public static void main(String args[]) &#123; Subject sub = new SubjectProxy(); sub.doSomething(); &#125;&#125; 刚开始我会觉得SubjectProxy定义出来纯属多余，直接实例化实现类完成操作不就结了吗？后来随着业务庞大，你就会知道，实现proxy类对真实类的封装对于粒度的控制有着重要的意义。但是静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题。 123456package test;public interface Subject &#123; public void doSomething(); &#125; 123456789package test;public class RealSubject implements Subject &#123; public void doSomething() &#123; System.out.println( "call doSomething()" ); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package test;import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class ProxyHandler implements InvocationHandler&#123; private Object tar; //绑定委托对象，并返回代理类 public Object bind(Object tar) &#123; this.tar = tar; //绑定该类实现的所有接口，取得代理类 return Proxy.newProxyInstance(tar.getClass().getClassLoader(), tar.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy , Method method , Object[] args)throws Throwable &#123; Object result = null; //这里就可以进行所谓的AOP编程了 //在调用具体函数方法前，执行功能处理 result = method.invoke(tar,args); //在调用具体函数方法后，执行功能处理 return result; &#125;&#125;public class TestProxy&#123; public static void main(String args[]) &#123; ProxyHandler proxy = new ProxyHandler(); //绑定该类实现的所有接口 Subject sub = (Subject) proxy.bind(new RealSubject()); sub.doSomething(); &#125;&#125; Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大； 可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用； 解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。 GClib代理 5、HashMap的并发问题HashMap在并发环境下多线程put后可能导致get死循环，具体表现为CPU使用率100%， 看一下transfer的过程： 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; //假设第一个线程执行到这里因为某种原因挂起 Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; 并发下的Rehash 1）假设我们有两个线程。我们再回头看一下我们的 transfer代码中的这个细节： 123456do &#123; Entry&lt;K,V&gt; next = e.next; // &lt;--假设线程一执行到这里就被调度挂起了 int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next;&#125; while (e != null); 而我们的线程二执行完成了。于是我们有下面的这个样子。 注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。 2）线程一被调度回来执行。 · 先是执行 newTalbe[i] = e; · 然后是e = next，导致了e指向了key(7)， · 而下一次循环的next = e.next导致了next指向了key(3) 3）一切安好。 线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。 4）环形链接出现。 e.next = newTable[i] 导致 key(3).next 指向了 key(7) 注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。 6、了解LinkedHashMap的应用吗LinkedHashMap实现与HashMap的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序（insert-order）或者是访问顺序，其中默认的迭代访问顺序就是插入顺序，即可以按插入的顺序遍历元素，这点和HashMap有很大的不同。 LinkedHashMap除了支持默认的插入顺序，还支持访问顺序。所谓访问顺序(access-order)是指在迭代遍历列表中的元素时最近访问的元素会排在LinkedHashMap的尾部 。从其构造函数中可以看出当accessOrder设为true时即为访问顺序。 123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 使用的时候，最近经常使用的元素就放在后面，最近最少使用的就排在了链表的前面。 基于LinkedHashMap的访问顺序的特点，可构造一个LRU（Least Recently Used）最近最少使用简单缓存。也有一些开源的缓存产品如ehcache的淘汰策略（LRU）就是在LinkedHashMap上扩展的。 7、反射的原理，反射创建类实例的三种方式是什么？ 假如你写了一段代码：Object o=new Object(); 运行起来。 首先JVM会启动，你的代码会编译成一个.class文件，然后被类加载器加载进jvm的内存中，把类信息保存在方法区数据结构中，并在Java堆中生成一个Class对象，作为类信息的入口,注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象 反射有什么用？通过Java的反射机制，可以在运行期间获取类的字段、方法、父类和接口等信息。 8、cloneable接口实现原理，浅拷贝or深拷贝​ clone方法执行的是浅拷贝， 在编写程序时要注意这个细节。如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。 会有不彻底的深拷贝。如何进行彻底的深拷贝？ ​如果在拷贝一个对象时，要想让这个拷贝的对象和源对象完全彼此独立，那么在引用链上的每一级对象都要被显式的拷贝。所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后的所有引用的对象都是被共享的。 如何利用序列化来完成对象的拷贝呢？ ​在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。 12345678910111213141516171819202122public class CloneUtils &#123; public static &lt;T extends Serializable&gt; T clone(T obj)&#123; T cloneObj = null; try &#123; //写入字节流 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream obs = new ObjectOutputStream(out); obs.writeObject(obj); obs.close(); //分配内存，写入原始对象，生成新对象 ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ios); //返回生成的新对象 cloneObj = (T) ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125; &#125; 9、Java NIO使用10、hashtable和hashmap的区别及实现原理11、LinkedList和ArrayList的区别及实现原理12、反射中，Class.forName和ClassLoader区别java中class.forName和classLoader都可用来对类进行加载。前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 13、有没有可能2个不相等的对象有相同的hashcode？有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。 二、JVM相关1、类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序先静态、先父后子。先静态：父静态 &gt; 子静态优先级：父类 &gt; 子类 静态代码块 &gt; 非静态代码块 &gt; 构造函数一个类的实例化过程： 父类中的static代码块，当前类的static 顺序执行父类的普通代码块 父类的构造函数 子类普通代码块 子类（当前类）的构造函数，按顺序执行。 子类方法的执行， 2、JVM内存分代Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM的内存分代策略。 为什么要分代？ 堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率，这简直太可怕了。 有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。 内存分代划分 Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且HotSpot也有取消永久代的趋势，在JDK 1.7中HotSpot已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。内存分代示意图如下： 新生代（Young） 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。 HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1。划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。 GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1，GC分代年龄存储在对象的header中）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。 老年代（Old） 在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。 永久代（Permanent） 永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。 Minor GC 和 Full GC的区别 新生代GC（Minor GC）：Minor GC指发生在新生代的GC，因为新生代的Java对象大多都是朝生夕死，所以Minor GC非常频繁，一般回收速度也比较快。当Eden空间不足以为对象分配内存时，会触发Minor GC。 老年代GC（Full GC/Major GC）：Full GC指发生在老年代的GC，出现了Full GC一般会伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代），比如：分配担保失败。Full GC的速度一般会比Minor GC慢10倍以上。当老年代内存不足或者显式调用System.gc()方法时，会触发Full GC。 3、Java 8的内存分代改进从永久代到元空间，在小范围自动扩展永生代避免溢出 4、jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代对象优先在新生代区中分配，若没有足够空间，Minor GC； 大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。 5、几种主要的jvm参数等-Xms：1G ， 就是说初始堆大小为1G-Xmx：2G ， 就是说最大堆大小为2G-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法-XX:SurvivorRatio=3 ， 就是说Eden区与Survivor区的大小比值为3：1：1 6、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms，g17、新生代和老生代的内存回收策略 新生代中采用的收集算法：复制算法。算法的思想是将可用内存分为大小相等的两块，每次使用其中一块，当一块内存用完了，就将还存活的对象分到另一块。然后把使用过的内存空间一次进行清理。这种算法缺点会明显，就是会浪费一半的空间。而根据IBM研究表明，新生代中98%的对象朝生夕死，所以不需要按照1:1进行分配，而是按照内存分为一块较大的Eden空间和两块较小的Survivor空间(from和to两个)，每次使用Eden和其中一个Survivor。当回收时，将Eden和其中一块Survivor中还存活着的对象一次性复制到另一块Survivor中，然后清理Eden和刚才用过的Survivor空间。一般默认的比例为：Eden：from：to＝8:1:1。注：可通过-XX:SurvivorRatio=i来设置，默认i＝8。当Survivor空间不够时，需要依赖其他内存(老年代)进行分配担保。内存的分配担保：如果另一块Survivor空间没有足够的内存空间存放上一次新生代收集下来的存活对象，那么这些对象将直接通过分配担保机制进入老年代。 ​ 老年代中采用的收集算法：标记－整理算法。算法思想：首先标记需要回收的对象，然后让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。 8、深入分析了Classloader，双亲委派机制9、JVM的编译优化10、对Java内存模型的理解，以及其在并发中的应用 11、指令重排序，内存栅栏等 12、OOM错误，stackoverflow错误，permgen space错误 13、tomcat结构，类加载器流程 14、volatile的语义，它修饰的变量一定线程安全吗 15、g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择CMS收集器：一款以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的，分为4个步骤：初始标记、并发标记、重新标记、并发清除。 G1收集器：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。整体上看是“标记-整理”，局部看是“复制”，不会产生内存碎片。吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。 说一说你对环境变量classpath的理解？如果一个类不在classpath下，为什么会抛出ClassNotFoundException异常，如果在不改变这个类路径的前期下，怎样才能正确加载这个类？说一下强引用、软引用、弱引用、虚引用以及他们之间和gc的关系 三、数据库1、MySQL InnoDB存储的文件结构从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment）、区（extent)、页（page）组成。页在一些文档中有时也称为块（block），InnoDB存储引擎的逻辑存储结构大致如图： 表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。 上图中显示了表空间是由各个段组成，常见的段有数据段、索引段、回滚段等。InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。那么数据段即为B+树的叶子节点（图中Leaf of node segment），索引段即为B+树的非索引节点（图中Nonleaf node segment）。 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性InnoDB存储引擎一次从磁盘申请4~5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。 同大多数数据库一样，InnoDB有页（Page）的概念（也可以称为块），页是InnoDB磁盘管理的最小单位。 2、索引树是如何维护的？下图是MyISAM索引的原理图： 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。 在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 InnoDB的所有辅助索引都引用主键作为data域。 3、数据库自增主键可能的问题 数据库单点造成无法水平切分 把公司业务的关键运营数据完全暴露 4、MySQL的几种优化​ https://www.awaimai.com/569.html 5、mysql索引为什么使用B+树一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 综上所述，用B-Tree作为索引结构效率是非常高的。 6、数据库锁表的相关处理​ 在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。 死锁的第一种情况 一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。 解决方法： 这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。 死锁的第二种情况 用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操作，很容易就出现这种死锁的情况。 解决方法： 1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。 2、使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。 3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。 死锁的第三种情况 如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。解决方法： SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。 7、索引失效场景 当or左右查询字段只有一个是索引，该索引失效，explain执行计划key=null；只有当or左右查询字段均为索引时，才会生效； 组合索引，不是使用第一列索引，索引失效 使用like模糊查询，当%在前缀时，索引失效;当前缀没有%，后缀有%时，索引有效 列类型是字符串，where时一定用引号括起来，否则索引失效 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效 四、网络相关http1.0和http1.1有什么区别TCP/IP协议TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么TIME_WAIT和CLOSE_WAIT的区别说说你知道的几种HTTP响应码当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤TCP/IP如何保证可靠性，数据包有哪些数据组成长连接与短连接Http请求get和post的区别以及数据包格式简述tcp建立连接3次握手，和断开连接4次握手的过程；关闭连接时，出现TIMEWAIT过多是由什么原因引起，是出现在主动断开方还是被动断开方。 五、其他maven解决依赖冲突,快照版和发行版的区别Linux下IO模型有几种，各自的含义是什么实际场景问题，海量登录日志如何排序和处理SQL操作，主要是索引和聚合函数的应用实际场景问题解决，典型的TOP K问题线上bug处理流程如何从线上日志发现问题linux利用哪些命令，查找哪里出了问题（例如io密集任务，cpu过度）场景问题，有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。用三个线程按顺序循环打印abc三个字母，比如abcabcabc。常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的设计一个秒杀系统，30分钟没付款就自动关闭交易（并发会很高）请列出你所了解的性能测试工具后台系统怎么防止请求重复提交？]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
